# 黑白模式与自动排列功能 - 技术实现规划

## 📋 需求概述

### 需求1：黑白模式 + 隐藏翻译
- **位置**：右上角
- **功能**：
  - 添加黑白模式切换按钮
  - 隐藏现有的中英文翻译按钮
- **效果**：点击后整个画布在黑白/彩色之间切换

### 需求2：自动排列功能
- **位置**：右下角（与缩放控制并列）
- **功能**：
  - 自动整理画布上的所有节点
  - 根据节点内容自动调整节点大小
  - 消除节点重叠，整齐排列
- **效果**：一键让混乱的画布变得整洁有序

---

## 🎯 需求1：黑白模式实现规划

### 1.1 当前UI结构分析

**现有代码位置**：`App.tsx` 第4022-4031行

```tsx
{/* Language Toggle Button */}
<div className="absolute top-8 right-8 z-50 animate-in fade-in slide-in-from-top-4 duration-700">
    <button
        onClick={() => setLanguage(language === 'zh' ? 'en' : 'zh')}
        className="flex items-center gap-2 px-4 py-2 bg-[#1c1c1e]/80 backdrop-blur-2xl border border-white/10 rounded-full shadow-2xl text-slate-300 hover:text-white hover:border-white/20 transition-all hover:scale-105"
        title={t.settings.language}
    >
        <Languages size={16} />
        <span className="text-xs font-medium">{language === 'zh' ? t.settings.english : t.settings.chinese}</span>
    </button>
</div>
```

### 1.2 黑白模式设计方案

#### 方案A：CSS滤镜方式（推荐⭐）

**优点**：
- 实现简单，无需修改节点组件
- 性能优秀，浏览器原生GPU加速
- 瞬间切换，无闪烁

**缺点**：
- 纯视觉黑白，不改变实际颜色值
- 可能影响某些UI元素的对比度

**实现要点**：
```tsx
// 在 App.tsx 添加状态
const [isGrayscale, setIsGrayscale] = useState(false);

// 在最外层容器应用滤镜
<div className={`App ${isGrayscale ? 'grayscale-mode' : ''}`}>
  <style>{`
    .grayscale-mode {
      filter: grayscale(100%);
    }
    .grayscale-mode * {
      filter: grayscale(100%) !important;
    }
  `}</style>
  {/* 画布内容 */}
</div>

// 替换语言切换按钮为黑白模式按钮
<button onClick={() => setIsGrayscale(!isGrayscale)}>
  <Sun size={16} /> {/* 或 Moon */}
  <span>{isGrayscale ? '彩色' : '黑白'}</span>
</button>
```

#### 方案B：主题切换方式

**优点**：
- 真实的黑白配色，可精细控制
- 可以针对不同元素调整灰度值

**缺点**：
- 需要定义完整的黑白主题色板
- 实现复杂度高
- 可能影响节点颜色识别

**实现要点**：
```tsx
// 定义黑白主题
const grayscaleColors = {
  [NodeType.IMAGE_GENERATOR]: '#4a4a4a',
  [NodeType.SCRIPT_PLANNER]: '#4a4a4a',
  // ... 所有节点颜色转为灰度
};

// 使用 CSS 变量
:root {
  --node-color: grayscale(var(--original-color));
}
```

**推荐选择**：方案A（CSS滤镜）

### 1.3 隐藏中英文翻译

**实现**：直接删除第4022-4031行的代码块

**或者**：保留代码但通过条件渲染隐藏
```tsx
{false && (
  <div className="absolute top-8 right-8...">
    {/* 语言切换按钮 */}
  </div>
)}
```

### 1.4 黑白模式图标建议

**选项1**：使用 `Sun`（彩色）和 `Moon`（黑白）图标
**选项2**：使用 `Eye`（查看）和 `EyeOff`（关闭）
**选项3**：使用 `Palette`（调色板）图标

**推荐**：选项1（Sun/Moon），直观易懂

### 1.5 实现文件清单

| 文件 | 修改内容 | 代码行数 |
|------|----------|----------|
| `App.tsx` | 添加 grayscale state | +5行 |
| `App.tsx` | 替换语言按钮为黑白模式按钮 | ~15行 |
| `App.tsx` | 添加 CSS 滤镜样式 | +10行 |
| **总计** | | **~30行** |

---

## 🎯 需求2：自动排列功能实现规划

### 2.1 当前UI结构分析

**现有代码位置**：`App.tsx` 第4033-4043行

```tsx
<div className="absolute bottom-8 right-8 flex items-center gap-3...">
  {/* 缩放控制 */}
  <button onClick={handleFitView} title="适配视图">
    <Scan size={14} />
  </button>
</div>
```

**需要添加**：在"适配视图"按钮旁边添加"自动排列"按钮

### 2.2 自动排列算法设计

#### 2.2.1 核心算法流程

```
1. 分析阶段
   ├─ 按节点类型分组
   ├─ 计算每个节点的内容密度
   ├─ 确定节点层级关系（上下游关系）
   └─ 估算每个节点的最佳尺寸

2. 布局计算阶段
   ├─ 使用层次化布局算法（如 Dagre 布局）
   ├─ 计算节点位置（避免连线交叉）
   ├─ 调整节点大小（根据内容密度）
   └─ 消除重叠，保持间距

3. 动画执行阶段
   ├─ 计算每个节点的目标位置
   ├─ 使用 CSS transform 实现平滑动画
   └─ 更新节点坐标到状态
```

#### 2.2.2 节点大小自动调整策略

**现有代码**：`utils/nodeHelpers.ts` 第80-132行

**当前逻辑**：
- 基础高度：根据节点类型（320-700px）
- 动态增加：根据内容数量（images、videos、shots等）

**改进策略**：

| 节点类型 | 内容指标 | 调整策略 |
|----------|----------|----------|
| IMAGE_GENERATOR | 图片数量 | 1张=360px, 2-3张=450px, 4+张=600px |
| SCRIPT_PLANNER | 文本长度 | <500字=480px, 500-1000字=550px, >1000字=650px |
| STORYBOARD_IMAGE | 分镜数量 | 基础600px + 每个分镜80px |
| CHARACTER_NODE | 角色数量 | 每个角色+70px，最大不超过900px |

**实现示例**：
```typescript
function calculateOptimalSize(node: AppNode): { width: number; height: number } {
  const baseWidth = 420;
  let height = getApproxNodeHeight(node);

  // 内容密度分析
  const contentDensity = analyzeContentDensity(node);

  // 根据密度调整宽度
  if (contentDensity > 0.8) {
    return { width: 520, height: height * 1.2 };
  } else if (contentDensity > 0.5) {
    return { width: 470, height: height * 1.1 };
  }

  return { width: baseWidth, height };
}
```

#### 2.2.3 布局算法选择

**方案A：网格布局（简单快速）**

```typescript
function gridLayout(nodes: AppNode[]) {
  const gridSize = 480; // 横向间距 + 节点宽度
  const gridHeight = 400; // 纵向间距

  nodes.forEach((node, index) => {
    const col = index % 4; // 每行4个节点
    const row = Math.floor(index / 4);

    node.x = col * gridSize;
    node.y = row * gridHeight;
  });
}
```

**优点**：实现简单，速度快
**缺点**：不考虑节点连接关系，连线可能混乱

**方案B：层次化布局（推荐⭐）**

```typescript
function hierarchicalLayout(nodes: AppNode[], connections: Connection[]) {
  // 1. 构建节点依赖图
  const graph = buildDependencyGraph(nodes, connections);

  // 2. 计算节点层级（Topological Sort）
  const levels = calculateLevels(graph);

  // 3. 每层节点横向排列
  levels.forEach((nodesInLevel, levelIndex) => {
    nodesInLevel.forEach((node, nodeIndex) => {
      node.x = levelIndex * 600; // 层级间距
      node.y = nodeIndex * 450;   // 节点间距
    });
  });

  // 4. 减少连线交叉（贪心算法）
  reduceEdgeCrossings(levels, connections);
}
```

**优点**：考虑节点关系，连线清晰
**缺点**：算法复杂，实现难度较高

**方案C：力导向布局**

```typescript
function forceDirectedLayout(nodes: AppNode[], connections: Connection[]) {
  // 使用 d3-force 或 elkjs 库
  // 模拟物理力：节点排斥力 + 连线引力
}
```

**优点**：布局自然，美观
**缺点**：需要引入外部库，可能过重

**推荐选择**：方案B（层次化布局）

### 2.3 动画效果设计

**使用 Framer Motion 或 CSS Transition**

```typescript
function animateLayout(nodes: AppNode[], newPositions: Map<string, {x, y}>) {
  nodes.forEach(node => {
    const targetPos = newPositions.get(node.id);

    // 使用 Web Animations API
    const element = document.getElementById(`node-${node.id}`);
    element?.animate([
      { transform: `translate(${node.x}px, ${node.y}px)` },
      { transform: `translate(${targetPos.x}px, ${targetPos.y}px)` }
    ], {
      duration: 500,
      easing: 'cubic-bezier(0.32, 0.72, 0, 1)'
    });
  });

  // 动画完成后更新状态
  setTimeout(() => {
    setNodes(nodes.map(n => ({
      ...n,
      ...newPositions.get(n.id)
    })));
  }, 500);
}
```

### 2.4 实现文件清单

| 文件 | 修改内容 | 代码行数 |
|------|----------|----------|
| `App.tsx` | 添加"自动排列"按钮 | +10行 |
| `utils/layoutAlgorithms.ts` | 新建布局算法文件 | +300行 |
| `utils/nodeHelpers.ts` | 扩展 `calculateOptimalSize` 函数 | +80行 |
| `App.tsx` | 实现 `handleAutoLayout` 函数 | +150行 |
| **总计** | | **~540行** |

---

## 📊 完整实现路线图

### 阶段1：黑白模式（优先级：高）

**工作量**：0.5天
**复杂度**：⭐

1. ✅ 分析现有UI结构
2. ⏳ 添加 grayscale state
3. ⏳ 实现CSS滤镜
4. ⏳ 替换语言按钮为黑白模式按钮
5. ⏳ 测试黑白切换效果

### 阶段2：基础自动排列（优先级：中）

**工作量**：1-2天
**复杂度**：⭐⭐⭐

1. ✅ 添加"自动排列"按钮到右下角
2. ⏳ 实现简单的网格布局算法
3. ⏳ 实现平滑动画过渡
4. ⏳ 测试基本排列效果

### 阶段3：智能节点大小调整（优先级：中）

**工作量**：1天
**复杂度**：⭐⭐

1. ✅ 分析各节点类型的内容密度
2. ⏳ 实现 `calculateOptimalSize` 函数
3. ⏳ 集成到自动排列流程
4. ⏳ 测试不同内容的节点大小

### 阶段4：层次化布局算法（优先级：低）

**工作量**：2-3天
**复杂度**：⭐⭐⭐⭐

1. ✅ 研究层次化布局算法
2. ⏳ 实现依赖图构建
3. ⏳ 实现层级计算
4. ⏳ 实现连线交叉减少
5. ⏳ 性能优化和测试

---

## 🎨 UI/UX 设计建议

### 黑白模式按钮设计

```
┌─────────────────────────────┐
│  [🌞 彩色]  悬浮在右上角    │
│  圆角胶囊形状              │
│  玻璃态背景 (backdrop-blur) │
│  点击切换为 [🌙 黑白]       │
└─────────────────────────────┘
```

### 自动排列按钮设计

```
┌─────────────────────────────────┐
│  ─── ⏸ ─── [📐 排列] ─── ⏹ ───  │
│  位于右下角缩放控制旁边           │
│  方形按钮，带图标                │
│  点击后显示加载动画               │
│  完成后显示对钩动画               │
└─────────────────────────────────┘
```

### 动画效果建议

**黑白模式切换**：
- 使用 CSS transition: `filter 0.3s ease`
- 按钮图标旋转 180 度

**自动排列动画**：
- 节点移动：500ms cubic-bezier(0.32, 0.72, 0, 1)
- 依次延迟启动（stagger）：每个节点延迟 50ms
- 尺寸变化：与移动同步进行

---

## ⚠️ 潜在问题与解决方案

### 问题1：黑白模式影响节点识别

**场景**：用户依赖节点颜色区分不同类型

**解决方案**：
- 提供一个"黑白模式但保留节点颜色"的选项
- 或在黑白模式下增加图标对比度

### 问题2：自动排列破坏用户手动布局

**场景**：用户已经精心安排了节点位置

**解决方案**：
- 添加撤销功能（Ctrl+Z）
- 提示用户"确定要重新排列吗？"
- 保留手动布局的"分组"结构

### 问题3：大量节点时性能问题

**场景**：画布上有50+个节点

**解决方案**：
- 分批动画（每次最多10个节点）
- 使用 Web Worker 进行布局计算
- 提供"快速排列"（无动画）选项

---

## 📈 预期效果

### 黑白模式
- ✅ 一键切换整个画布的视觉风格
- ✅ 适合打印、截图分享
- ✅ 减少视觉干扰，专注内容

### 自动排列
- ✅ 3秒内整理50个混乱的节点
- ✅ 连线清晰，无交叉
- ✅ 节点大小根据内容自适应
- ✅ 保持节点间的合理间距

---

## 🛠️ 技术栈建议

| 需求 | 推荐技术 |
|------|----------|
| 黑白模式 | CSS filter, useState |
| 自动排列算法 | Dagre, elkjs, 或自定义算法 |
| 动画效果 | Web Animations API 或 Framer Motion |
| 性能优化 | Web Worker, requestAnimationFrame |

---

## 📝 实现前的准备工作

1. **确认黑白模式的确切需求**
   - 是否需要"单色模式"（只有黑白）还是"灰度模式"（保留颜色明度）？
   - 是否需要让用户自定义灰度级别？

2. **确认自动排列的优先级**
   - 是否保持现有的分组（Group）结构？
   - 是否需要考虑节点的"重要性"来决定位置？

3. **性能基准测试**
   - 测试100个节点的动画性能
   - 确定合理的动画时长和曲线

4. **用户反馈收集**
   - 提供原型图给用户确认
   - 收集关于动画速度、布局风格的反馈

---

## ✅ 实现检查清单

### 黑白模式
- [ ] 添加状态管理
- [ ] 实现CSS滤镜
- [ ] 替换语言按钮
- [ ] 添加图标切换动画
- [ ] 测试不同节点类型的黑白效果
- [ ] 测试连线、背景的黑白效果

### 自动排列
- [ ] 添加UI按钮
- [ ] 实现基础网格布局
- [ ] 实现节点大小计算
- [ ] 实现平滑动画
- [ ] 添加撤销功能
- [ ] 测试不同节点数量（10/50/100个）
- [ ] 测试有连接和无连接的场景

---

## 🎓 参考资源

**布局算法**：
- [Dagre](https://github.com/dagrejs/dagre) - 有向图布局库
- [ELK](https://github.com/kieler/elkjs) - 多层级布局库
- [d3-force](https://github.com/d3/d3-force) - 力导向布局

**动画库**：
- [Framer Motion](https://www.framer.com/motion/)
- [React Spring](https://www.react-spring.dev/)
- Web Animations API (原生)

**UI设计参考**：
- Figma 的自动布局功能
- Miro 的智能排列功能
- Notion 的拖拽整理功能

---

## 💡 未来扩展方向

1. **智能布局模式**
   - "流程图模式"：突出数据流向
   - "网状模式"：强调节点关系
   - "树状模式"：清晰展示层级

2. **自定义主题**
   - 让用户选择不同的黑白风格
   - 提供高对比度、护眼等模式

3. **布局模板**
   - 保存常用布局
   - 一键应用"故事创作流程"等预设布局

4. **智能分组**
   - 自动识别相关节点
   - 创建可视化的分组框

---

**文档版本**：v1.0
**创建日期**：2025-01-24
**作者**：Claude Sonnet 4.5
**状态**：规划阶段，待开发确认
